- **Bubble Sort**<br><br>
  1-1. **Bubble Sort에 대해 설명하시오** <br>
  Bubble Sort는 서로 인접한 두 원소를 비교하여 정렬하는 알고리즘이다. 0번 인덱스부터 n-1번 인덱스까지 n번까지의 모든 인덱스를 비교하며 정렬합니다.
  
  1-2. **Bubble Sort의 시간 복잡도와 Worst Case의 시간복잡도를 설명하시오** <br>
  시간복잡도는 O(n^2) : {(n-1)+(n-2)+(n-3)+...+1=(n-1)n/2}이며, WorstCase는 중간에 정렬이 완료되도, 마지막 회차까지 비교하기 때문에 시간복잡도 O(n^2)와 동일하다.
  
  1-3. **Bubble Sort의 Worst Case인 경우 어떤 일이 일어난건지 설명하시오** <br>
  역순으로 정렬된 입력 자료의 경우가 Worst Case이다.
  <br>
- **Heap Sort**<br><br>
  2-1. **Heap Sort에 대해 설명하시오** <br>
  Heap Sort는 주어진 데이터를 Heap 자료구조로 만들어 최대값 또는 최소값부터 하나씩 꺼내서 정렬하는 알고리즘이다. 

  2-2. **Heap Sort의 시간 복잡도와 Worst Case의 시간복잡도를 설명하시오** <br>
  시간복잡도는 O(nlog2n)이다. 이는 깊이 값인 log2n과 정렬해야할 개수 n을 곱한 값이다. 최악의 경우 역시도 O(nlog2n)이다.
  
  2-3. **Heap Sort의 Worst Case인 경우 어떤 일이 일어난건지 설명하시오** <br>
  찾고자 하는 노드가 말단에 삽입한 원소로 이것이 루트 노드까지 올라가는 상황이 Worst Case이다.
  <br>
- **Merge Sort**<br><br>
  3-1. **Merge Sort에 대해 설명하시오** <br>
  Merge Sort는 주어진 배열을 크기가 1인 배열로 분할하고 합병하면서 정렬을 진행하는 분할/정복 알고리즘이다.
  
  3-2. **Merge Sort의 시간 복잡도와 Worst Case의 시간복잡도를 설명하시오** <br>
  시간복잡도는 O(nlog2n)이다. 여기서 log2n은 순환 호출의 길이고, n은 각 합병 단계에서의 비교 연산을 의미한다. 최악의 경우 역시도 O(nlog2n)이다.
  
  3-3. **Merge Sort의 Worst Case인 경우 어떤 일이 일어난건지 설명하시오** <br>
  예를 들어, 1357/2468 처럼 왼쪽과 오른쪽 배열이 대체되는 원소를 서로 각각 가지고 있을 때이다.
  <br>
- **Quick Sort**<br><br>
  4-1. **Quick Sort에 대해 설명하시오** <br>
  먼저 pivot을 결정한다. 여기서는 pivot을 결정하는 방법 중에 첫번쨰, 중간, 마지막, 랜덤 인덱스가 있다. 왼쪽부터 오른족으로 pivot보다 큰값이 나올 경우까지 이동하며,
   오른쪽에서 왼쪽으로 pivot보다 작은 값이 나올 경우까지 이동한다. 이후에 각각의 값이 나온 경우에는 swap을 한다. 그리고 서로 교차한다면 그 값과 pivot을 swap한다.
   이제 pivot을 기준으로 왼쪽 구간, 오른쪽 구간이 나뉘고, 위의 방법을 계속 반복한다.
   
  4-2. **Quick Sort의 시간 복잡도와 Worst Case의 시간복잡도를 설명하시오** <br>
  시간복잡도는 O(nlog(n))이다. Worst Case의 시간복잡도는 O(n^2)이다.
  
  4-3. **최선과 최악의 Case를 각각 설명하시오** <br>
  최선의 경우는 피봇을 기준으로 정확히 반반이 나뉠때이고, 최악의 경우는 pivot을 기준으로 한쪽으로만 치우쳐져서 나뉘었을 때이다. 
  
  4-4. **최악을 막는 방법을 설명하시오** <br>
  pivot을 설정할때, 랜덤 혹은 중간 인덱스로 선택하면 최악의 pivot이 나올 확률을 줄여주게 된다.
  
- **Insertion Sort(삽입 정렬)**<br><br>
  5-1. **Insertion Sort에 대해 설명하시오**<br>
  두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다.
  
  5-2. **Insertion Sort의 시간 복잡도와 Worst Case의 시간복잡도를 설명하시오** <br>
  시간복잡도는 O(n^2)이며, 이는 n개를 n번 교환한걸 의미한다. Worst Case의 시간복잡도도 역시 O(n^2)이다. 참고로, 최선의 시간복잡도 O(n)이다.
  
  5-3. **최선과 최악의 case를 각각 설명하시오** <br>
  최선은 이동 없이 1번의 비교만 이루어진 경우와, 최악의 경우는 배열이 역순으로 정렬되어 있는 경우다.
  
- **동적 프로그래밍(Dynamic Programming)**<br><br>
  6-1. **동적 프로그래밍이 무엇인지 설명하시오.**<br>
  동적 프로그래밍(Dynamic Programming)이란 주어진 문제를 풀기 위해서, 문제를 여러 개의 하위 문제(Subproblem)로 나누어 푼 다음, 그것을 결합하여 해결하는 방식이다. 
  또한 그 결과를 재활용하는 메모이제이션(Memoization) 기법으로 속도를 향상시킬 수 있다.
  
  6-2. **동적 프로그래밍의 두 가지 조건을 설명하시오**<br>
  첫 번째는 Overlapping으로 같은 부분 문제가 여러번 재사용되는 것이며, 두 번째는 Optimal로 새로운 부분 문제의 정답이 다른 부분 문제의 정답으로 구할 수 있는 경우이다.
  
  6-3. **재귀 알고리즘의 시간 복잡도를 설명하시오**<br>
  시간복잡도는 O(n)이다.
  
- **허프만 코딩**<br><br>
  7-1. **허프만 코딩이 무엇인지 설명하시오**<br>
  문자의 빈도를 이용해 압축하는 방법으로 빈도가 높은 문자에 짧은 코드를 부여하는 방식이다. 
  
